{"version":3,"file":"index.min.js","sources":["../src/ndef-text.js","../src/ndef-uri.js","../src/ndef.js"],"sourcesContent":["/**\n  * decode text bytes from ndef record payload\n  *\n  * @returns a string\n  */\nexport const decode = data => {\n    var languageCodeLength = (data[0] & 0x3F), // 6 LSBs\n        languageCode = data.slice(1, 1 + languageCodeLength),\n        utf16 = (data[0] & 0x80) !== 0 // assuming UTF-16BE\n\n    // TODO need to deal with UTF in the future\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\n\n    return Buffer.from(data.slice(languageCodeLength + 1)).toString()\n}\n\n/**\n  * Encode text payload\n  *\n  * @returns an array of bytes\n  */\nexport const encode = (text, lang, encoding) => {\n    // ISO/IANA language code, but we're not enforcing\n    if (!lang) {\n      lang = 'en'\n    }\n\n    var encoded = Buffer.from([lang.length, ...Array.prototype.slice.call(Buffer.from(lang + text), 0)])\n\n    return encoded\n}\n","// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\n// index in array matches code in the spec\nconst protocols = [ \"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\" ]\n\n/**\n  * @returns a string\n  */\nexport const decode = data => {\n    var prefix = protocols[data[0]]\n    if (!prefix) { // 36 to 255 should be \"\"\n        prefix = \"\"\n    }\n    return prefix + Buffer.from(data.slice(1)).toString()\n}\n\n/**\n  * shorten a URI with standard prefix\n  *\n  * @returns an array of bytes\n  */\nexport const encode = uri => {\n    var prefix,\n        protocolCode,\n        encoded\n\n    // check each protocol, unless we've found a match\n    // \"urn:\" is the one exception where we need to keep checking\n    // slice so we don't check \"\"\n    protocols.slice(1).forEach(protocol => {\n      if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\n        prefix = protocol\n      }\n    })\n\n    if (!prefix) {\n        prefix = \"\"\n    }\n\n    protocolCode = protocols.indexOf(prefix)\n    encoded = Buffer.from([protocolCode, ...Array.prototype.slice.call(Buffer.from(uri.slice(prefix.length)), 0)])\n\n    return encoded\n}\n","// ndef.js\n// Copyright 2013 Don Coleman\n//\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\n\n// see android.nfc.NdefRecord for documentation about constants\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\n\nimport constants from './constants.yaml'\n\nimport {\n  encode as encodeTextPayload,\n  decode as decodeTextPayload\n} from './ndef-text'\n\nimport {\n  encode as encodeUriPayload,\n  decode as decodeUriPayload\n} from './ndef-uri'\n\nexport { constants }\n\n// convert bytes to a String\nconst s = bytes =>\n Buffer.from(bytes).toString()\n\n/**\n * Creates a JSON representation of a NDEF Record.\n *\n * @tnf 3-bit TNF (Type Name Format) - use one of the constants.TNF_* constants\n * @type byte array, containing zero to 255 bytes, must not be null\n * @id byte array, containing zero to 255 bytes, must not be null\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\n *\n * @returns JSON representation of a NDEF record\n *\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\n */\n\nexport const record = (tnf = constants.TNF_EMPTY, type = [], id = [], payload = [], value) => {\n  // store type as String so it's easier to compare\n  if(type instanceof Array) {\n    type = Buffer.from(type).toString()\n  }\n\n  // in the future, id could be a String\n  if (!(id instanceof Array)) {\n    id = Buffer.from(id)\n  }\n\n  // Payload must be binary\n  if (!(payload instanceof Array)) {\n    payload = Buffer.from(payload)\n  }\n\n  // Experimental feature\n  // Convert payload to text for Text and URI records\n  if (tnf == constants.TNF_WELL_KNOWN) {\n    if(type == constants.RTD_TEXT) {\n      value = decodeTextPayload(payload)\n    }\n    else if(type == constants.RTD_URI) {\n      value = decodeUriPayload(payload)\n    }\n  }\n\n  return {\n    tnf,\n    type,\n    id,\n    payload,\n    value\n  }\n}\n\n/**\n * Helper that creates an NDEF record containing plain text.\n *\n * @text String of text to encode\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\n * @id byte[] (optional)\n */\nexport const textRecord = (text, languageCode, id = []) =>\n  record(constants.TNF_WELL_KNOWN, constants.RTD_TEXT, id, encodeTextPayload(text, languageCode))\n\n/**\n * Helper that creates a NDEF record containing a URI.\n *\n * @uri String\n * @id byte[] (optional)\n */\nexport const uriRecord = (uri, id = []) =>\n  record(constants.TNF_WELL_KNOWN, constants.RTD_URI, id, encodeUriPayload(uri))\n\n/**\n * Helper that creates a NDEF record containing an absolute URI.\n *\n * An Absolute URI record means the URI describes the payload of the record.\n *\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\n * as the type and XML content for the payload.\n *\n * Absolute URI can also be used to write LaunchApp records for Windows.\n *\n * See 2.4.2 Payload Type of the NDEF Specification\n * http://www.nfc-forum.org/specs/spec_list#ndefts\n *\n * Note that by default, Android will open the URI defined in the type\n * field of an Absolute URI record (TNF=3) and ignore the payload.\n * BlackBerry and Windows do not open the browser for TNF=3.\n *\n * To write a URI as the payload use ndef.uriRecord(uri)\n *\n * @uri String\n * @payload byte[] or String\n * @id byte[] (optional)\n */\nexport const absoluteUriRecord = (uri, payload = [], id = []) =>\n  record(constants.TNF_ABSOLUTE_URI, uri, id, payload)\n\n/**\n* Helper that creates a NDEF record containing an mimeMediaRecord.\n*\n* @mimeType String\n* @payload byte[]\n* @id byte[] (optional)\n*/\nexport const mimeMediaRecord = (mimeType, payload = [], id = []) =>\n  record(constants.TNF_MIME_MEDIA, mimeType, id, payload)\n\n/**\n* Helper that creates an NDEF record containing an Smart Poster.\n*\n* @ndefRecords array of NDEF Records\n* @id byte[] (optional)\n*/\nexport const smartPoster = (ndefRecords, id, payload) => {\n  payload = []\n\n  if (ndefRecords) {\n    // make sure we have an array of something like NDEF records before encoding\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\n      payload = encodeMessage(ndefRecords)\n    } else {\n      // assume the caller has already encoded the NDEF records into a byte array\n      payload = ndefRecords\n    }\n  } else {\n    //console.warn(\"WARNING: Expecting an array of NDEF records\")\n    throw new Error('Expecting an array of NDEF records')\n  }\n\n  return record(constants.TNF_WELL_KNOWN, constants.RTD_SMART_POSTER, id, payload)\n}\n\n/**\n* Helper that creates an empty NDEF record.\n*\n*/\nexport const emptyRecord = () =>\n  record(constants.TNF_EMPTY, [], [], [])\n\n/**\n* Helper that creates an Android Application Record (AAR).\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\n*\n*/\nexport const androidApplicationRecord = packageName =>\n  record(constants.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName)\n\n/**\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\n*\n* @ndefRecords an Array of NDEF Records\n*\n* @returns byte array\n*\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\n*/\nexport const encodeMessage = ndefRecords => {\n  let encoded = [],\n      tnf_byte,\n      record_type,\n      payload_length,\n      id_length,\n      i,\n      mb, me, // messageBegin, messageEnd\n      cf = false, // chunkFlag TODO implement\n      sr, // boolean shortRecord\n      il // boolean idLengthFieldIsPresent\n\n  for (i = 0; i < ndefRecords.length; i++) {\n    mb = (i === 0)\n    me = (i === (ndefRecords.length - 1))\n    sr = (ndefRecords[i].payload.length < 0xFF)\n    il = (ndefRecords[i].id.length > 0)\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf)\n    encoded.push(tnf_byte)\n\n    // type is stored as String, converting to bytes for storage\n    record_type = Array.prototype.slice.call(Buffer.from(ndefRecords[i].type), 0)\n    encoded.push(record_type.length)\n\n    if (sr) {\n      payload_length = ndefRecords[i].payload.length\n      encoded.push(payload_length)\n    } else {\n      payload_length = ndefRecords[i].payload.length\n      // 4 bytes\n      encoded.push((payload_length >> 24))\n      encoded.push((payload_length >> 16))\n      encoded.push((payload_length >> 8))\n      encoded.push((payload_length & 0xFF))\n    }\n\n    if (il) {\n      id_length = ndefRecords[i].id.length\n      encoded.push(id_length)\n    }\n\n    encoded = encoded.concat(record_type)\n\n    if (il) {\n      encoded = encoded.concat(ndefRecords[i].id)\n    }\n\n    encoded = encoded.concat(Array.prototype.slice.call(ndefRecords[i].payload, 0))\n  }\n\n  return encoded\n}\n\n/**\n* Decodes an array bytes into an NDEF Message\n*\n* @bytes an array bytes read from a NFC tag\n*\n* @returns array of NDEF Records\n*\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\n*/\nexport const decodeMessage = _bytes => {\n  let bytes = _bytes.slice(0), // clone since parsing is destructive\n      ndef_message = [],\n      tnf_byte,\n      header,\n      type_length = 0,\n      payload_length = 0,\n      id_length = 0,\n      record_type = [],\n      id = [],\n      payload = []\n\n  while(bytes.length) {\n    tnf_byte = bytes.shift()\n    header = decodeTnf(tnf_byte)\n\n    type_length = bytes.shift()\n\n    if (header.sr) {\n      payload_length = bytes.shift()\n    } else {\n      // next 4 bytes are length\n      payload_length = ((0xFF & bytes.shift()) << 24) |\n        ((0xFF & bytes.shift()) << 16) |\n        ((0xFF & bytes.shift()) << 8) |\n        (0xFF & bytes.shift())\n    }\n\n    if (header.il) {\n      id_length = bytes.shift()\n    }\n\n    record_type = bytes.splice(0, type_length)\n    id = bytes.splice(0, id_length)\n    payload = bytes.splice(0, payload_length)\n\n    ndef_message.push(\n      record(header.tnf, record_type, id, payload)\n    )\n\n    if (header.me) {\n      // last message\n      break\n    }\n  }\n\n  return ndef_message\n}\n\n/**\n* Decode the bit flags from a TNF Byte.\n*\n* @returns object with decoded data\n*\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\n*/\nexport const decodeTnf = (tnf_byte) => {\n  return {\n    mb: (tnf_byte & 0x80) !== 0,\n    me: (tnf_byte & 0x40) !== 0,\n    cf: (tnf_byte & 0x20) !== 0,\n    sr: (tnf_byte & 0x10) !== 0,\n    il: (tnf_byte & 0x8) !== 0,\n    tnf: (tnf_byte & 0x7)\n  }\n}\n\n/**\n* Encode NDEF bit flags into a TNF Byte.\n*\n* @returns tnf byte\n*\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\n*/\nexport const encodeTnf = (mb, me, cf, sr, il, tnf, value = tnf) => {\n  if (mb) {\n    value = value | 0x80\n  }\n\n  if (me) {\n    value = value | 0x40\n  }\n\n  // note if cf: me, mb, li must be false and tnf must be 0x6\n  if (cf) {\n    value = value | 0x20\n  }\n\n  if (sr) {\n    value = value | 0x10\n  }\n\n  if (il) {\n    value = value | 0x8\n  }\n\n  return value\n}\n\n// TODO test with byte[] and string\nexport const isType = (record, tnf, type) =>\n  record.tnf === tnf\n    ? s(record) === s(type)\n    : false\n\n// export const tnfToString = (tnf, value = tnf) => {\n//   if(tnf == constants.TNF_EMPTY) {\n//     value = \"Empty\"\n//   }\n//   else if(constants.TNF_WELL_KNOWN) {\n//     value = \"Well Known\"\n//   }\n//   else if(constants.TNF_MIME_MEDIA) {\n//     value = \"Mime Media\"\n//   }\n//   else if(constants.TNF_ABSOLUTE_URI) {\n//     value = \"Absolute URI\"\n//   }\n//   else if(constants.TNF_EXTERNAL_TYPE) {\n//     value = \"External\"\n//   }\n//   else if(constants.TNF_UNKNOWN) {\n//     value = \"Unknown\"\n//   }\n//   else if(constants.TNF_UNCHANGED) {\n//     value = \"Unchanged\"\n//   }\n//   else if(constants.TNF_RESERVED) {\n//     value = \"Reserved\"\n//   }\n//   return value\n// }\n\n// Convert NDEF records and messages to strings\n// This works OK for demos, but real code proably needs\n// a custom implementation. It would be nice to make\n// smarter record objects that can print themselves\n// var stringifier = {\n//     stringify: function (data, separator) {\n//       if (Array.isArray(data)) {\n//         if (typeof data[0] === 'number') {\n//           // guessing this message bytes\n//           data = decodeMessage(data)\n//         }\n//\n//         return stringifier.printRecords(data, separator)\n//       } else {\n//         return stringifier.printRecord(data, separator)\n//       }\n//     },\n//\n//     // @message - NDEF Message (array of NDEF Records)\n//     // @separator - line separator, optional, defaults to \\n\n//     // @returns string with NDEF Message\n//     printRecords: function (message, separator) {\n//\n//         if(!separator) { separator = \"\\n\" }\n//         result = \"\"\n//\n//         // Print out the payload for each record\n//         message.forEach(function(record) {\n//             result += stringifier.printRecord(record, separator)\n//             result += separator\n//         })\n//\n//         return result.slice(0, (-1 * separator.length))\n//     },\n//\n//     // @record - NDEF Record\n//     // @separator - line separator, optional, defaults to \\n\n//     // @returns string with NDEF Record\n//     printRecord: function (record, separator) {\n//\n//         var result = \"\"\n//\n//         if(!separator) { separator = \"\\n\" }\n//\n//         switch(record.tnf) {\n//             case ndef.constants.TNF_EMPTY:\n//                 result += \"Empty Record\"\n//                 result += separator\n//                 break\n//             case ndef.constants.TNF_WELL_KNOWN:\n//                 result += stringifier.printWellKnown(record, separator)\n//                 break\n//             case ndef.constants.TNF_MIME_MEDIA:\n//                 result += \"MIME Media\"\n//                 result += separator\n//                 result += s(record.type)\n//                 result += separator\n//                 result += s(record.payload) // might be binary\n//                 break\n//             case ndef.constants.TNF_ABSOLUTE_URI:\n//                 result += \"Absolute URI\"\n//                 result += separator\n//                 result += s(record.type)    // the URI is the type\n//                 result += separator\n//                 result += s(record.payload) // might be binary\n//                 break\n//             case ndef.constants.TNF_EXTERNAL_TYPE:\n//                 // AAR contains strings, other types could\n//                 // contain binary data\n//                 result += \"External\"\n//                 result += separator\n//                 result += s(record.type)\n//                 result += separator\n//                 result += s(record.payload)\n//                 break\n//             default:\n//                 result += s(\"Can't process TNF \" + record.tnf)\n//         }\n//\n//         result += separator\n//         return result\n//     },\n//\n//     printWellKnown: function (record, separator) {\n//\n//         var result = \"\"\n//\n//         if (record.tnf !== ndef.constants.TNF_WELL_KNOWN) {\n//             return \"ERROR expecting TNF Well Known\"\n//         }\n//\n//         switch(record.type) {\n//             case ndef.constants.RTD_TEXT:\n//                 result += \"Text Record\"\n//                 result += separator\n//                 result += (ndef.text.decodePayload(record.payload))\n//                 break\n//             case ndef.constants.RTD_URI:\n//                 result += \"URI Record\"\n//                 result += separator\n//                 result += (ndef.uri.decodePayload(record.payload))\n//                 break\n//             case ndef.constants.RTD_SMART_POSTER:\n//                 result += \"Smart Poster\"\n//                 result += separator\n//                 // the payload of a smartposter is a NDEF message\n//                 result += stringifier.printRecords(ndef.decodeMessage(record.payload))\n//                 break\n//             default:\n//                 // attempt to display other types\n//                 result += record.type + \" Record\"\n//                 result += separator\n//                 result += s(record.payload)\n//         }\n//\n//         return result\n//     }\n// }\n//\n// export const stringify = { stringifier }\n"],"names":["decode","languageCodeLength","data","slice","Buffer","from","toString","encode","text","lang","encoding","length","Array","prototype","call","protocols","prefix","protocolCode","forEach","uri","indexOf","protocol","s","bytes","record","tnf","constants","TNF_EMPTY","type","id","payload","value","TNF_WELL_KNOWN","RTD_TEXT","decodeTextPayload","RTD_URI","decodeUriPayload","encodeMessage","encoded","tnf_byte","record_type","payload_length","id_length","i","mb","me","ndefRecords","encodeTnf","sr","il","push","concat","decodeTnf","cf","languageCode","encodeTextPayload","encodeUriPayload","TNF_ABSOLUTE_URI","mimeType","TNF_MIME_MEDIA","Error","Object","hasOwnProperty","RTD_SMART_POSTER","TNF_EXTERNAL_TYPE","packageName","_bytes","header","type_length","shift","splice","ndef_message"],"mappings":"8YAKaA,EAAS,gBACdC,EAAgC,GAAVC,EAAK,GACZA,EAAKC,MAAM,EAAG,EAAIF,UAM9BG,OAAOC,KAAKH,EAAKC,MAAMF,EAAqB,IAAIK,YAQ9CC,EAAS,SAACC,EAAMC,EAAMC,UAE1BD,MACI,MAGKL,OAAOC,MAAMI,EAAKE,eAAWC,MAAMC,UAAUV,MAAMW,KAAKV,OAAOC,KAAKI,EAAOD,GAAO,MCzB9FO,GAAc,GAAI,cAAe,eAAgB,UAAW,WAAY,OAAQ,UAAW,6BAA8B,aAAc,UAAW,UAAW,SAAU,SAAU,SAAU,SAAU,QAAS,YAAa,QAAS,UAAW,OAAQ,OAAQ,OAAQ,QAAS,QAAS,WAAY,aAAc,YAAa,aAAc,cAAe,UAAW,cAAe,eAAgB,eAAgB,eAAgB,WAAY,YAK5af,EAAS,gBACdgB,EAASD,EAAUb,EAAK,WACvBc,MACQ,IAENA,EAASZ,OAAOC,KAAKH,EAAKC,MAAM,IAAIG,YAQlCC,EAAS,gBACdS,EACAC,WAMMd,MAAM,GAAGe,QAAQ,YACnBF,GAAqB,SAAXA,GAAgD,IAA1BG,EAAIC,QAAQC,OACvCA,KAIRL,MACQ,MAGED,EAAUK,QAAQJ,GACvBZ,OAAOC,MAAMY,UAAiBL,MAAMC,UAAUV,MAAMW,KAAKV,OAAOC,KAAKc,EAAIhB,MAAMa,EAAOL,SAAU,MChBxGW,EAAI,mBACTlB,OAAOC,KAAKkB,GAAOjB,YAePkB,EAAS,eAACC,yDAAMC,EAAUC,UAAWC,4DAAWC,4DAASC,4DAAcC,sBAE/EH,aAAgBhB,UACVR,OAAOC,KAAKuB,GAAMtB,YAIrBuB,aAAcjB,UACbR,OAAOC,KAAKwB,IAIbC,aAAmBlB,UACbR,OAAOC,KAAKyB,IAKpBL,GAAOC,EAAUM,iBAChBJ,GAAQF,EAAUO,WACXC,EAAkBJ,GAEpBF,GAAQF,EAAUS,YAChBC,EAAiBN,4CAqHlBO,EAAgB,gBACvBC,KACAC,SACAC,SACAC,SACAC,SACAC,SACAC,SAAIC,+BAKHF,EAAI,EAAGA,EAAIG,EAAYnC,OAAQgC,MACtB,IAANA,IACAA,IAAOG,EAAYnC,OAAS,IAC5BmC,EAAYH,GAAGb,QAAQnB,OAAS,MAChCmC,EAAYH,GAAGd,GAAGlB,OAAS,IACtBoC,EAAUH,EAAIC,GATlB,EAS0BG,EAAIC,EAAIH,EAAYH,GAAGlB,OAChDyB,KAAKX,KAGC3B,MAAMC,UAAUV,MAAMW,KAAKV,OAAOC,KAAKyC,EAAYH,GAAGf,MAAO,KACnEsB,KAAKV,EAAY7B,QAErBqC,KACeF,EAAYH,GAAGb,QAAQnB,SAChCuC,KAAKT,OAEIK,EAAYH,GAAGb,QAAQnB,SAEhCuC,KAAMT,GAAkB,MACxBS,KAAMT,GAAkB,MACxBS,KAAMT,GAAkB,KACxBS,KAAuB,IAAjBT,IAGZQ,MACUH,EAAYH,GAAGd,GAAGlB,SACtBuC,KAAKR,MAGLJ,EAAQa,OAAOX,GAErBS,MACQX,EAAQa,OAAOL,EAAYH,GAAGd,OAGhCS,EAAQa,OAAOvC,MAAMC,UAAUV,MAAMW,KAAKgC,EAAYH,GAAGb,QAAS,WAGvEQ,GAoEIc,EAAY,SAACb,aAEI,IAAV,IAAXA,MACqB,IAAV,GAAXA,MACqB,IAAV,GAAXA,MACqB,IAAV,GAAXA,MACoB,IAAT,EAAXA,OACY,EAAXA,IAWGQ,EAAY,SAACH,EAAIC,EAAIQ,EAAIL,EAAIC,EAAIxB,OAAKM,yDAAQN,SACrDmB,OACc,KAGdC,OACc,IAIdQ,OACc,IAGdL,OACc,IAGdC,OACc,GAGXlB,2DA/PiB,SAACvB,EAAM8C,OAAczB,mEAC7CL,EAAOE,EAAUM,eAAgBN,EAAUO,SAAUJ,EAAI0B,EAAkB/C,EAAM8C,uBAQ1D,SAACnC,OAAKU,mEAC7BL,EAAOE,EAAUM,eAAgBN,EAAUS,QAASN,EAAI2B,EAAiBrC,+BAyB1C,SAACA,OAAKW,4DAAcD,mEACnDL,EAAOE,EAAU+B,iBAAkBtC,EAAKU,EAAIC,4BASf,SAAC4B,OAAU5B,4DAAcD,mEACtDL,EAAOE,EAAUiC,eAAgBD,EAAU7B,EAAIC,wBAQtB,SAACgB,EAAajB,EAAIC,YAGvCgB,QAUI,IAAIc,MAAM,+CARZd,EAAY,aAAce,QAAUf,EAAY,GAAGgB,eAAe,OAC1DzB,EAAcS,GAGdA,EAOPtB,EAAOE,EAAUM,eAAgBN,EAAUqC,iBAAkBlC,EAAIC,wBAO/C,kBACzBN,EAAOE,EAAUC,sDAOqB,mBACtCH,EAAOE,EAAUsC,kBAAmB,qBAAuBC,kDAyEhC,oBACvB1C,EAAQ2C,EAAO/D,MAAM,QAErBoC,SACA4B,SACAC,EAAc,EACd3B,EAAiB,EACjBC,EAAY,EACZF,KACAX,KACAC,KAEEP,EAAMZ,WACCY,EAAM8C,UACRjB,EAAUb,KAELhB,EAAM8C,UAEhBF,EAAOnB,GACQzB,EAAM8C,SAGJ,IAAO9C,EAAM8C,UAAY,IACxC,IAAO9C,EAAM8C,UAAY,IACzB,IAAO9C,EAAM8C,UAAY,EAC1B,IAAO9C,EAAM8C,QAGdF,EAAOlB,OACG1B,EAAM8C,WAGN9C,EAAM+C,OAAO,EAAGF,KACzB7C,EAAM+C,OAAO,EAAG5B,KACXnB,EAAM+C,OAAO,EAAG7B,KAEbS,KACX1B,EAAO2C,EAAO1C,IAAKe,EAAaX,EAAIC,KAGlCqC,EAAOtB,aAMN0B,0DAsDa,SAAC/C,EAAQC,EAAKG,UAClCJ,EAAOC,MAAQA,GACXH,EAAEE,KAAYF,EAAEM"}