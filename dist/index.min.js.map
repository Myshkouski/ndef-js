{"version":3,"file":"index.min.js","sources":["../src/ndef-util.js","../src/ndef-text.js","../src/ndef-uri.js","../src/ndef.js"],"sourcesContent":["// ndef-util.js\n// Copyright 2013 Don Coleman\n//\n\n// This is from phonegap-nfc.js and is a combination of helpers in nfc and util\n// https://github.com/chariotsolutions/phonegap-nfc/blob/master/www/phonegap-nfc.js\n\nfunction stringToBytes(string) {\n    var bytes = Buffer(string).toJSON();\n    if (bytes.hasOwnProperty('data')) {\n        // Node 0.12.x\n        return bytes.data;\n    } else {\n        // Node 0.10.x\n        return bytes;\n    }\n}\n\nfunction bytesToString(bytes) {\n    return Buffer(bytes).toString();\n}\n\n// useful for readable version of Tag UID\nfunction bytesToHexString(bytes) {\n    var dec, hexstring, bytesAsHexString = \"\";\n    for (var i = 0; i < bytes.length; i++) {\n       if (bytes[i] >= 0) {\n           dec = bytes[i];\n       } else {\n           dec = 256 + bytes[i];\n       }\n       hexstring = dec.toString(16);\n       // zero padding\n       if (hexstring.length == 1) {\n           hexstring = \"0\" + hexstring;\n       }\n       bytesAsHexString += hexstring;\n    }\n    return bytesAsHexString;\n}\n\n// i must be <= 256\nfunction toHex(i) {\n    var hex;\n\n    if (i < 0) {\n        i += 256;\n    }\n    hex = i.toString(16);\n\n    // zero padding\n    if (hex.length == 1) {\n        hex = \"0\" + hex;\n    }\n    return hex;\n}\n\nfunction toPrintable(i) {\n    if (i >= 0x20 & i <= 0x7F) {\n        return String.fromCharCode(i);\n    } else {\n        return '.';\n    }\n}\n\nexport {\n  stringToBytes,\n  bytesToString,\n  bytesToHexString,\n  toHex,\n  toPrintable\n}\n","import {\n  bytesToString,\n  stringToBytes\n} from './ndef-util'\n\n/**\n  * decode text bytes from ndef record payload\n  *\n  * @returns a string\n  */\nexport const decode = data => {\n    var languageCodeLength = (data[0] & 0x3F), // 6 LSBs\n        languageCode = data.slice(1, 1 + languageCodeLength),\n        utf16 = (data[0] & 0x80) !== 0 // assuming UTF-16BE\n\n    // TODO need to deal with UTF in the future\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\n\n    return bytesToString(data.slice(languageCodeLength + 1))\n}\n\n/**\n  * Encode text payload\n  *\n  * @returns an array of bytes\n  */\nexport const encode = (text, lang, encoding) => {\n    // ISO/IANA language code, but we're not enforcing\n    if (!lang) { lang = 'en' }\n\n    var encoded = stringToBytes(lang + text)\n    encoded.unshift(lang.length)\n\n    return encoded\n}\n","import {\n  bytesToString,\n  stringToBytes\n} from './ndef-util'\n\n// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\n// index in array matches code in the spec\nconst protocols = [ \"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\" ]\n\n/**\n  * @returns a string\n  */\nexport const decode = data => {\n    var prefix = protocols[data[0]]\n    if (!prefix) { // 36 to 255 should be \"\"\n        prefix = \"\"\n    }\n    return prefix + bytesToString(data.slice(1))\n}\n\n/**\n  * shorten a URI with standard prefix\n  *\n  * @returns an array of bytes\n  */\nexport const encode = uri => {\n    var prefix,\n        protocolCode,\n        encoded\n\n    // check each protocol, unless we've found a match\n    // \"urn:\" is the one exception where we need to keep checking\n    // slice so we don't check \"\"\n    protocols.slice(1).forEach(protocol => {\n      if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\n        prefix = protocol\n      }\n    })\n\n    if (!prefix) {\n        prefix = \"\"\n    }\n\n    encoded = stringToBytes(uri.slice(prefix.length))\n    protocolCode = protocols.indexOf(prefix)\n    // prepend protocol code\n    encoded.unshift(protocolCode)\n\n    return encoded\n}\n","// ndef.js\n// Copyright 2013 Don Coleman\n//\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\n\n// see android.nfc.NdefRecord for documentation about constants\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\n\nimport {\n  TNF_EMPTY,\n  TNF_WELL_KNOWN,\n  TNF_MIME_MEDIA,\n  TNF_ABSOLUTE_URI,\n  TNF_EXTERNAL_TYPE,\n  TNF_UNKNOWN,\n  TNF_UNCHANGED,\n  TNF_RESERVED,\n\n  RTD_TEXT,\n  RTD_URI,\n  RTD_SMART_POSTER,\n  RTD_ALTERNATIVE_CARRIER,\n  RTD_HANDOVER_CARRIER,\n  RTD_HANDOVER_REQUEST,\n  RTD_HANDOVER_SELECT\n} from './constants.yaml'\n\nimport {\n  bytesToString,\n  stringToBytes\n} from './ndef-util'\n\nimport {\n  encode as encodeTextPayload,\n  decode as decodeTextPayload\n} from './ndef-text'\n\nimport {\n  encode as encodeUriPayload,\n  decode as decodeUriPayload\n} from './ndef-uri'\n\n/**\n * Creates a JSON representation of a NDEF Record.\n *\n * @tnf 3-bit TNF (Type Name Format) - use one of the TNF_* constants\n * @type byte array, containing zero to 255 bytes, must not be null\n * @id byte array, containing zero to 255 bytes, must not be null\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\n *\n * @returns JSON representation of a NDEF record\n *\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\n */\n\n// convert bytes to a String\nconst s = bytes =>\n  new Buffer(bytes).toString()\n\nexport const record = (tnf = TNF_EMPTY, type = [], id = [], payload = [], value) => {\n  // store type as String so it's easier to compare\n  if(type instanceof Array) {\n    type = bytesToString(type)\n  }\n\n  // in the future, id could be a String\n  if (!(id instanceof Array)) {\n    id = stringToBytes(id)\n  }\n\n  // Payload must be binary\n  if (!(payload instanceof Array)) {\n    payload = stringToBytes(payload)\n  }\n\n  // Experimental feature\n  // Convert payload to text for Text and URI records\n  if (tnf == TNF_WELL_KNOWN) {\n    if(type == RTD_TEXT) {\n      value = decodeTextPayload(payload)\n    }\n    else if(type == RTD_URI) {\n      value = decodeUriPayload(payload)\n    }\n  }\n\n  return {\n    tnf,\n    type,\n    id,\n    payload,\n    value\n  }\n}\n\n/**\n * Helper that creates an NDEF record containing plain text.\n *\n * @text String of text to encode\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\n * @id byte[] (optional)\n */\nexport const textRecord = (text, languageCode, id = []) =>\n  record(TNF_WELL_KNOWN, RTD_TEXT, id, encodeTextPayload(text, languageCode))\n\n/**\n * Helper that creates a NDEF record containing a URI.\n *\n * @uri String\n * @id byte[] (optional)\n */\nexport const uriRecord = (uri, id = []) =>\n  record(TNF_WELL_KNOWN, RTD_URI, id, encodeUriPayload(uri))\n\n/**\n * Helper that creates a NDEF record containing an absolute URI.\n *\n * An Absolute URI record means the URI describes the payload of the record.\n *\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\n * as the type and XML content for the payload.\n *\n * Absolute URI can also be used to write LaunchApp records for Windows.\n *\n * See 2.4.2 Payload Type of the NDEF Specification\n * http://www.nfc-forum.org/specs/spec_list#ndefts\n *\n * Note that by default, Android will open the URI defined in the type\n * field of an Absolute URI record (TNF=3) and ignore the payload.\n * BlackBerry and Windows do not open the browser for TNF=3.\n *\n * To write a URI as the payload use ndef.uriRecord(uri)\n *\n * @uri String\n * @payload byte[] or String\n * @id byte[] (optional)\n */\nexport const absoluteUriRecord = (uri, payload = [], id = []) =>\n  record(TNF_ABSOLUTE_URI, uri, id, payload)\n\n/**\n* Helper that creates a NDEF record containing an mimeMediaRecord.\n*\n* @mimeType String\n* @payload byte[]\n* @id byte[] (optional)\n*/\nexport const mimeMediaRecord = (mimeType, payload = [], id = []) =>\n  record(TNF_MIME_MEDIA, mimeType, id, payload)\n\n/**\n* Helper that creates an NDEF record containing an Smart Poster.\n*\n* @ndefRecords array of NDEF Records\n* @id byte[] (optional)\n*/\nexport const smartPoster = (ndefRecords, id, payload) => {\n  payload = []\n\n  if (ndefRecords) {\n    // make sure we have an array of something like NDEF records before encoding\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\n      payload = encodeMessage(ndefRecords)\n    } else {\n      // assume the caller has already encoded the NDEF records into a byte array\n      payload = ndefRecords\n    }\n  } else {\n    console.warn(\"WARNING: Expecting an array of NDEF records\")\n  }\n\n  return record(TNF_WELL_KNOWN, RTD_SMART_POSTER, id, payload)\n}\n\n/**\n* Helper that creates an empty NDEF record.\n*\n*/\nexport const emptyRecord = () =>\n  record(TNF_EMPTY, [], [], [])\n\n/**\n* Helper that creates an Android Application Record (AAR).\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\n*\n*/\nexport const androidApplicationRecord = packageName =>\n  record(TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName)\n\n/**\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\n*\n* @ndefRecords an Array of NDEF Records\n*\n* @returns byte array\n*\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\n*/\nexport const encodeMessage = (ndefRecords) => {\n  let encoded = [],\n      tnf_byte,\n      record_type,\n      payload_length,\n      id_length,\n      i,\n      mb, me, // messageBegin, messageEnd\n      cf = false, // chunkFlag TODO implement\n      sr, // boolean shortRecord\n      il // boolean idLengthFieldIsPresent\n\n  for (i = 0; i < ndefRecords.length; i++) {\n    mb = (i === 0)\n    me = (i === (ndefRecords.length - 1))\n    sr = (ndefRecords[i].payload.length < 0xFF)\n    il = (ndefRecords[i].id.length > 0)\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf)\n    encoded.push(tnf_byte)\n\n    // type is stored as String, converting to bytes for storage\n    record_type = stringToBytes(ndefRecords[i].type)\n    encoded.push(record_type.length)\n\n    if (sr) {\n      payload_length = ndefRecords[i].payload.length\n      encoded.push(payload_length)\n    } else {\n      payload_length = ndefRecords[i].payload.length\n      // 4 bytes\n      encoded.push((payload_length >> 24))\n      encoded.push((payload_length >> 16))\n      encoded.push((payload_length >> 8))\n      encoded.push((payload_length & 0xFF))\n    }\n\n    if (il) {\n      id_length = ndefRecords[i].id.length\n      encoded.push(id_length)\n    }\n\n    encoded = encoded.concat(record_type)\n\n    if (il) {\n      encoded = encoded.concat(ndefRecords[i].id)\n    }\n\n    encoded = encoded.concat(ndefRecords[i].payload)\n  }\n\n  return encoded\n}\n\n/**\n* Decodes an array bytes into an NDEF Message\n*\n* @bytes an array bytes read from a NFC tag\n*\n* @returns array of NDEF Records\n*\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\n*/\nexport const decodeMessage = _bytes => {\n  let bytes = _bytes.slice(0), // clone since parsing is destructive\n      ndef_message = [],\n      tnf_byte,\n      header,\n      type_length = 0,\n      payload_length = 0,\n      id_length = 0,\n      record_type = [],\n      id = [],\n      payload = []\n\n  while(bytes.length) {\n    tnf_byte = bytes.shift()\n    header = decodeTnf(tnf_byte)\n\n    type_length = bytes.shift()\n\n    if (header.sr) {\n      payload_length = bytes.shift()\n    } else {\n      // next 4 bytes are length\n      payload_length = ((0xFF & bytes.shift()) << 24) |\n        ((0xFF & bytes.shift()) << 16) |\n        ((0xFF & bytes.shift()) << 8) |\n        (0xFF & bytes.shift())\n    }\n\n    if (header.il) {\n      id_length = bytes.shift()\n    }\n\n    record_type = bytes.splice(0, type_length)\n    id = bytes.splice(0, id_length)\n    payload = bytes.splice(0, payload_length)\n\n    ndef_message.push(\n      record(header.tnf, record_type, id, payload)\n    )\n\n    if (header.me) break // last message\n  }\n\n  return ndef_message\n}\n\n/**\n* Decode the bit flags from a TNF Byte.\n*\n* @returns object with decoded data\n*\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\n*/\nexport const decodeTnf = (tnf_byte) => {\n  return {\n    mb: (tnf_byte & 0x80) !== 0,\n    me: (tnf_byte & 0x40) !== 0,\n    cf: (tnf_byte & 0x20) !== 0,\n    sr: (tnf_byte & 0x10) !== 0,\n    il: (tnf_byte & 0x8) !== 0,\n    tnf: (tnf_byte & 0x7)\n  }\n}\n\n/**\n* Encode NDEF bit flags into a TNF Byte.\n*\n* @returns tnf byte\n*\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\n*/\nexport const encodeTnf = (mb, me, cf, sr, il, tnf, value = tnf) => {\n  if (mb) {\n    value = value | 0x80\n  }\n\n  if (me) {\n    value = value | 0x40\n  }\n\n  // note if cf: me, mb, li must be false and tnf must be 0x6\n  if (cf) {\n    value = value | 0x20\n  }\n\n  if (sr) {\n    value = value | 0x10\n  }\n\n  if (il) {\n    value = value | 0x8\n  }\n\n  return value\n}\n\n// TODO test with byte[] and string\nexport const isType = (record, tnf, type) =>\n  record.tnf === tnf\n    ? s(record) === s(type)\n    : false\n\nexport const tnfToString = (tnf, value = tnf) => {\n  if(tnf == TNF_EMPTY) {\n    value = \"Empty\"\n  }\n  else if(TNF_WELL_KNOWN) {\n    value = \"Well Known\"\n  }\n  else if(TNF_MIME_MEDIA) {\n    value = \"Mime Media\"\n  }\n  else if(TNF_ABSOLUTE_URI) {\n    value = \"Absolute URI\"\n  }\n  else if(TNF_EXTERNAL_TYPE) {\n    value = \"External\"\n  }\n  else if(TNF_UNKNOWN) {\n    value = \"Unknown\"\n  }\n  else if(TNF_UNCHANGED) {\n    value = \"Unchanged\"\n  }\n  else if(TNF_RESERVED) {\n    value = \"Reserved\"\n  }\n  return value\n}\n\n// Convert NDEF records and messages to strings\n// This works OK for demos, but real code proably needs\n// a custom implementation. It would be nice to make\n// smarter record objects that can print themselves\nvar stringifier = {\n    stringify: function (data, separator) {\n      if (Array.isArray(data)) {\n        if (typeof data[0] === 'number') {\n          // guessing this message bytes\n          data = decodeMessage(data)\n        }\n\n        return stringifier.printRecords(data, separator)\n      } else {\n        return stringifier.printRecord(data, separator)\n      }\n    },\n\n    // @message - NDEF Message (array of NDEF Records)\n    // @separator - line separator, optional, defaults to \\n\n    // @returns string with NDEF Message\n    printRecords: function (message, separator) {\n\n        if(!separator) { separator = \"\\n\" }\n        result = \"\"\n\n        // Print out the payload for each record\n        message.forEach(function(record) {\n            result += stringifier.printRecord(record, separator)\n            result += separator\n        })\n\n        return result.slice(0, (-1 * separator.length))\n    },\n\n    // @record - NDEF Record\n    // @separator - line separator, optional, defaults to \\n\n    // @returns string with NDEF Record\n    printRecord: function (record, separator) {\n\n        var result = \"\"\n\n        if(!separator) { separator = \"\\n\" }\n\n        switch(record.tnf) {\n            case ndef.TNF_EMPTY:\n                result += \"Empty Record\"\n                result += separator\n                break\n            case ndef.TNF_WELL_KNOWN:\n                result += stringifier.printWellKnown(record, separator)\n                break\n            case ndef.TNF_MIME_MEDIA:\n                result += \"MIME Media\"\n                result += separator\n                result += s(record.type)\n                result += separator\n                result += s(record.payload) // might be binary\n                break\n            case ndef.TNF_ABSOLUTE_URI:\n                result += \"Absolute URI\"\n                result += separator\n                result += s(record.type)    // the URI is the type\n                result += separator\n                result += s(record.payload) // might be binary\n                break\n            case ndef.TNF_EXTERNAL_TYPE:\n                // AAR contains strings, other types could\n                // contain binary data\n                result += \"External\"\n                result += separator\n                result += s(record.type)\n                result += separator\n                result += s(record.payload)\n                break\n            default:\n                result += s(\"Can't process TNF \" + record.tnf)\n        }\n\n        result += separator\n        return result\n    },\n\n    printWellKnown: function (record, separator) {\n\n        var result = \"\"\n\n        if (record.tnf !== ndef.TNF_WELL_KNOWN) {\n            return \"ERROR expecting TNF Well Known\"\n        }\n\n        switch(record.type) {\n            case ndef.RTD_TEXT:\n                result += \"Text Record\"\n                result += separator\n                result += (ndef.text.decodePayload(record.payload))\n                break\n            case ndef.RTD_URI:\n                result += \"URI Record\"\n                result += separator\n                result += (ndef.uri.decodePayload(record.payload))\n                break\n            case ndef.RTD_SMART_POSTER:\n                result += \"Smart Poster\"\n                result += separator\n                // the payload of a smartposter is a NDEF message\n                result += stringifier.printRecords(ndef.decodeMessage(record.payload))\n                break\n            default:\n                // attempt to display other types\n                result += record.type + \" Record\"\n                result += separator\n                result += s(record.payload)\n        }\n\n        return result\n    }\n}\n\nexport const stringify = { stringifier }\n"],"names":["stringToBytes","string","bytes","Buffer","toJSON","hasOwnProperty","data","bytesToString","toString","decode","languageCodeLength","slice","encode","text","lang","encoding","encoded","unshift","length","protocols","prefix","protocolCode","forEach","uri","indexOf","protocol","s","record","tnf","TNF_EMPTY","type","id","payload","value","Array","TNF_WELL_KNOWN","RTD_TEXT","decodeTextPayload","RTD_URI","decodeUriPayload","encodeMessage","ndefRecords","tnf_byte","record_type","payload_length","id_length","i","mb","me","encodeTnf","sr","il","push","concat","decodeMessage","_bytes","header","type_length","shift","decodeTnf","splice","ndef_message","cf","stringifier","separator","isArray","printRecords","printRecord","message","result","ndef","printWellKnown","TNF_MIME_MEDIA","TNF_ABSOLUTE_URI","TNF_EXTERNAL_TYPE","decodePayload","RTD_SMART_POSTER","stringify","languageCode","encodeTextPayload","encodeUriPayload","mimeType","Object","warn","packageName","TNF_UNKNOWN","TNF_UNCHANGED","TNF_RESERVED"],"mappings":"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"}