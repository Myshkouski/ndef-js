{"version":3,"file":"index.min.js","sources":["../src/ndef-text.js","../src/ndef-uri.js","../src/ndef.js"],"sourcesContent":["/**\r\n  * decode text bytes from ndef record payload\r\n  *\r\n  * @returns a string\r\n  */\r\nexport const decode = data => {\r\n    var languageCodeLength = (data[0] & 0x3F), // 6 LSBs\r\n        languageCode = data.slice(1, 1 + languageCodeLength),\r\n        utf16 = (data[0] & 0x80) !== 0 // assuming UTF-16BE\r\n\r\n    // TODO need to deal with UTF in the future\r\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\r\n\r\n    return Buffer.from(data.slice(languageCodeLength + 1)).toString()\r\n}\r\n\r\n/**\r\n  * Encode text payload\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nexport const encode = (text, lang, encoding) => {\r\n    // ISO/IANA language code, but we're not enforcing\r\n    if (!lang) {\r\n      lang = 'en'\r\n    }\r\n\r\n    var encoded = Buffer.from([lang.length, ...Array.prototype.slice.call(Buffer.from(lang + text), 0)])\r\n\r\n    return encoded\r\n}\r\n","// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\r\n// index in array matches code in the spec\r\nconst protocols = [ \"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\" ]\r\n\r\n/**\r\n  * @returns a string\r\n  */\r\nexport const decode = data => {\r\n    var prefix = protocols[data[0]]\r\n    if (!prefix) { // 36 to 255 should be \"\"\r\n        prefix = \"\"\r\n    }\r\n    return prefix + Buffer.from(data.slice(1)).toString()\r\n}\r\n\r\n/**\r\n  * shorten a URI with standard prefix\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nexport const encode = uri => {\r\n    var prefix,\r\n        protocolCode,\r\n        encoded\r\n\r\n    // check each protocol, unless we've found a match\r\n    // \"urn:\" is the one exception where we need to keep checking\r\n    // slice so we don't check \"\"\r\n    protocols.slice(1).forEach(protocol => {\r\n      if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\r\n        prefix = protocol\r\n      }\r\n    })\r\n\r\n    if (!prefix) {\r\n        prefix = \"\"\r\n    }\r\n\r\n    protocolCode = protocols.indexOf(prefix)\r\n    encoded = Buffer.from([protocolCode, ...Array.prototype.slice.call(Buffer.from(uri.slice(prefix.length)), 0)])\r\n\r\n    return encoded\r\n}\r\n","// ndef.js\r\n// Copyright 2013 Don Coleman\r\n//\r\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\r\n\r\n// see android.nfc.NdefRecord for documentation about constants\r\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\r\n\r\nimport constants from './constants.yaml'\r\n\r\nimport {\r\n  encode as encodeTextPayload,\r\n  decode as decodeTextPayload\r\n} from './ndef-text'\r\n\r\nimport {\r\n  encode as encodeUriPayload,\r\n  decode as decodeUriPayload\r\n} from './ndef-uri'\r\n\r\nexport { constants }\r\n\r\n// convert bytes to a String\r\nconst s = bytes =>\r\n Buffer.from(bytes).toString()\r\n\r\n/**\r\n * Creates a JSON representation of a NDEF Record.\r\n *\r\n * @tnf 3-bit TNF (Type Name Format) - use one of the constants.TNF_* constants\r\n * @type byte array, containing zero to 255 bytes, must not be null\r\n * @id byte array, containing zero to 255 bytes, must not be null\r\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\r\n *\r\n * @returns JSON representation of a NDEF record\r\n *\r\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\r\n */\r\n\r\nexport const record = (tnf, type, id, payload, value) => {\r\n  if(!tnf) {\r\n    tnf = constants.TNF_EMPTY\r\n  }\r\n  if(!type) {\r\n    type = []\r\n  }\r\n  if(!id) {\r\n    id = []\r\n  }\r\n  if(!payload) {\r\n    payload = []\r\n  }\r\n  // store type as String so it's easier to compare\r\n  if(type instanceof Array) {\r\n    type = Buffer.from(type).toString()\r\n  }\r\n\r\n  // in the future, id could be a String\r\n  if (!(id instanceof Array)) {\r\n    id = Buffer.from(id)\r\n  }\r\n\r\n  // Payload must be binary\r\n  if (!(payload instanceof Array)) {\r\n    payload = Buffer.from(payload)\r\n  }\r\n\r\n  // Experimental feature\r\n  // Convert payload to text for Text and URI records\r\n  if (tnf == constants.TNF_WELL_KNOWN) {\r\n    if(type == constants.RTD_TEXT) {\r\n      value = decodeTextPayload(payload)\r\n    }\r\n    else if(type == constants.RTD_URI) {\r\n      value = decodeUriPayload(payload)\r\n    }\r\n  }\r\n\r\n  return {\r\n    tnf,\r\n    type,\r\n    id,\r\n    payload,\r\n    value\r\n  }\r\n}\r\n\r\n/**\r\n * Helper that creates an NDEF record containing plain text.\r\n *\r\n * @text String of text to encode\r\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\r\n * @id byte[] (optional)\r\n */\r\nexport const textRecord = (text, languageCode, id) =>\r\n  record(constants.TNF_WELL_KNOWN, constants.RTD_TEXT, id || [], encodeTextPayload(text, languageCode))\r\n\r\n/**\r\n * Helper that creates a NDEF record containing a URI.\r\n *\r\n * @uri String\r\n * @id byte[] (optional)\r\n */\r\nexport const uriRecord = (uri, id) =>\r\n  record(constants.TNF_WELL_KNOWN, constants.RTD_URI, id || [], encodeUriPayload(uri))\r\n\r\n/**\r\n * Helper that creates a NDEF record containing an absolute URI.\r\n *\r\n * An Absolute URI record means the URI describes the payload of the record.\r\n *\r\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\r\n * as the type and XML content for the payload.\r\n *\r\n * Absolute URI can also be used to write LaunchApp records for Windows.\r\n *\r\n * See 2.4.2 Payload Type of the NDEF Specification\r\n * http://www.nfc-forum.org/specs/spec_list#ndefts\r\n *\r\n * Note that by default, Android will open the URI defined in the type\r\n * field of an Absolute URI record (TNF=3) and ignore the payload.\r\n * BlackBerry and Windows do not open the browser for TNF=3.\r\n *\r\n * To write a URI as the payload use ndef.uriRecord(uri)\r\n *\r\n * @uri String\r\n * @payload byte[] or String\r\n * @id byte[] (optional)\r\n */\r\nexport const absoluteUriRecord = (uri, payload, id) =>\r\n  record(constants.TNF_ABSOLUTE_URI, uri, id || [], payload || [])\r\n\r\n/**\r\n* Helper that creates a NDEF record containing an mimeMediaRecord.\r\n*\r\n* @mimeType String\r\n* @payload byte[]\r\n* @id byte[] (optional)\r\n*/\r\nexport const mimeMediaRecord = (mimeType, payload, id) =>\r\n  record(constants.TNF_MIME_MEDIA, mimeType, id || [], payload || [])\r\n\r\n/**\r\n* Helper that creates an NDEF record containing an Smart Poster.\r\n*\r\n* @ndefRecords array of NDEF Records\r\n* @id byte[] (optional)\r\n*/\r\nexport const smartPoster = (ndefRecords, id) => {\r\n  let payload = []\r\n\r\n  if (ndefRecords) {\r\n    // make sure we have an array of something like NDEF records before encoding\r\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\r\n      payload = encodeMessage(ndefRecords)\r\n    } else {\r\n      // assume the caller has already encoded the NDEF records into a byte array\r\n      payload = ndefRecords\r\n    }\r\n  } else {\r\n    //console.warn(\"WARNING: Expecting an array of NDEF records\")\r\n    throw new Error('Expecting an array of NDEF records')\r\n  }\r\n\r\n  return record(constants.TNF_WELL_KNOWN, constants.RTD_SMART_POSTER, id, payload)\r\n}\r\n\r\n/**\r\n* Helper that creates an empty NDEF record.\r\n*\r\n*/\r\nexport const emptyRecord = () =>\r\n  record(constants.TNF_EMPTY, [], [], [])\r\n\r\n/**\r\n* Helper that creates an Android Application Record (AAR).\r\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\r\n*\r\n*/\r\nexport const androidApplicationRecord = packageName =>\r\n  record(constants.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName)\r\n\r\n/**\r\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\r\n*\r\n* @ndefRecords an Array of NDEF Records\r\n*\r\n* @returns byte array\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nexport const encodeMessage = ndefRecords => {\r\n  let encoded = [],\r\n      tnf_byte,\r\n      record_type,\r\n      payload_length,\r\n      id_length,\r\n      i,\r\n      mb, me, // messageBegin, messageEnd\r\n      cf = false, // chunkFlag TODO implement\r\n      sr, // boolean shortRecord\r\n      il // boolean idLengthFieldIsPresent\r\n\r\n  for (i = 0; i < ndefRecords.length; i++) {\r\n    mb = (i === 0)\r\n    me = (i === (ndefRecords.length - 1))\r\n    sr = (ndefRecords[i].payload.length < 0xFF)\r\n    il = (ndefRecords[i].id.length > 0)\r\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf)\r\n    encoded.push(tnf_byte)\r\n\r\n    // type is stored as String, converting to bytes for storage\r\n    record_type = Array.prototype.slice.call(Buffer.from(ndefRecords[i].type), 0)\r\n    encoded.push(record_type.length)\r\n\r\n    if (sr) {\r\n      payload_length = ndefRecords[i].payload.length\r\n      encoded.push(payload_length)\r\n    } else {\r\n      payload_length = ndefRecords[i].payload.length\r\n      // 4 bytes\r\n      encoded.push((payload_length >> 24))\r\n      encoded.push((payload_length >> 16))\r\n      encoded.push((payload_length >> 8))\r\n      encoded.push((payload_length & 0xFF))\r\n    }\r\n\r\n    if (il) {\r\n      id_length = ndefRecords[i].id.length\r\n      encoded.push(id_length)\r\n    }\r\n\r\n    encoded = encoded.concat(record_type)\r\n\r\n    if (il) {\r\n      encoded = encoded.concat(ndefRecords[i].id)\r\n    }\r\n\r\n    encoded = encoded.concat(Array.prototype.slice.call(ndefRecords[i].payload, 0))\r\n  }\r\n\r\n  return encoded\r\n}\r\n\r\n/**\r\n* Decodes an array bytes into an NDEF Message\r\n*\r\n* @bytes an array bytes read from a NFC tag\r\n*\r\n* @returns array of NDEF Records\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nexport const decodeMessage = _bytes => {\r\n  let bytes = _bytes.slice(0), // clone since parsing is destructive\r\n      ndef_message = [],\r\n      tnf_byte,\r\n      header,\r\n      type_length = 0,\r\n      payload_length = 0,\r\n      id_length = 0,\r\n      record_type = [],\r\n      id = [],\r\n      payload = []\r\n\r\n  while(bytes.length) {\r\n    tnf_byte = bytes.shift()\r\n    header = decodeTnf(tnf_byte)\r\n\r\n    type_length = bytes.shift()\r\n\r\n    if (header.sr) {\r\n      payload_length = bytes.shift()\r\n    } else {\r\n      // next 4 bytes are length\r\n      payload_length = ((0xFF & bytes.shift()) << 24) |\r\n        ((0xFF & bytes.shift()) << 16) |\r\n        ((0xFF & bytes.shift()) << 8) |\r\n        (0xFF & bytes.shift())\r\n    }\r\n\r\n    if (header.il) {\r\n      id_length = bytes.shift()\r\n    }\r\n\r\n    record_type = bytes.splice(0, type_length)\r\n    id = bytes.splice(0, id_length)\r\n    payload = bytes.splice(0, payload_length)\r\n\r\n    ndef_message.push(\r\n      record(header.tnf, record_type, id, payload)\r\n    )\r\n\r\n    if (header.me) {\r\n      // last message\r\n      break\r\n    }\r\n  }\r\n\r\n  return ndef_message\r\n}\r\n\r\n/**\r\n* Decode the bit flags from a TNF Byte.\r\n*\r\n* @returns object with decoded data\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nexport const decodeTnf = tnf_byte => {\r\n  return {\r\n    mb: (tnf_byte & 0x80) !== 0,\r\n    me: (tnf_byte & 0x40) !== 0,\r\n    cf: (tnf_byte & 0x20) !== 0,\r\n    sr: (tnf_byte & 0x10) !== 0,\r\n    il: (tnf_byte & 0x8) !== 0,\r\n    tnf: (tnf_byte & 0x7)\r\n  }\r\n}\r\n\r\n/**\r\n* Encode NDEF bit flags into a TNF Byte.\r\n*\r\n* @returns tnf byte\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nexport const encodeTnf = (mb, me, cf, sr, il, tnf, value) => {\r\n  if(!value) {\r\n    value = tnf\r\n  }\r\n\r\n  if (mb) {\r\n    value = value | 0x80\r\n  }\r\n\r\n  if (me) {\r\n    value = value | 0x40\r\n  }\r\n\r\n  // note if cf: me, mb, li must be false and tnf must be 0x6\r\n  if (cf) {\r\n    value = value | 0x20\r\n  }\r\n\r\n  if (sr) {\r\n    value = value | 0x10\r\n  }\r\n\r\n  if (il) {\r\n    value = value | 0x8\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n// TODO test with byte[] and string\r\nexport const isType = (record, tnf, type) =>\r\n  record.tnf === tnf\r\n    ? s(record) === s(type)\r\n    : false\r\n\r\n// export const tnfToString = (tnf, value = tnf) => {\r\n//   if(tnf == constants.TNF_EMPTY) {\r\n//     value = \"Empty\"\r\n//   }\r\n//   else if(constants.TNF_WELL_KNOWN) {\r\n//     value = \"Well Known\"\r\n//   }\r\n//   else if(constants.TNF_MIME_MEDIA) {\r\n//     value = \"Mime Media\"\r\n//   }\r\n//   else if(constants.TNF_ABSOLUTE_URI) {\r\n//     value = \"Absolute URI\"\r\n//   }\r\n//   else if(constants.TNF_EXTERNAL_TYPE) {\r\n//     value = \"External\"\r\n//   }\r\n//   else if(constants.TNF_UNKNOWN) {\r\n//     value = \"Unknown\"\r\n//   }\r\n//   else if(constants.TNF_UNCHANGED) {\r\n//     value = \"Unchanged\"\r\n//   }\r\n//   else if(constants.TNF_RESERVED) {\r\n//     value = \"Reserved\"\r\n//   }\r\n//   return value\r\n// }\r\n\r\n// Convert NDEF records and messages to strings\r\n// This works OK for demos, but real code proably needs\r\n// a custom implementation. It would be nice to make\r\n// smarter record objects that can print themselves\r\n// var stringifier = {\r\n//     stringify: function (data, separator) {\r\n//       if (Array.isArray(data)) {\r\n//         if (typeof data[0] === 'number') {\r\n//           // guessing this message bytes\r\n//           data = decodeMessage(data)\r\n//         }\r\n//\r\n//         return stringifier.printRecords(data, separator)\r\n//       } else {\r\n//         return stringifier.printRecord(data, separator)\r\n//       }\r\n//     },\r\n//\r\n//     // @message - NDEF Message (array of NDEF Records)\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Message\r\n//     printRecords: function (message, separator) {\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//         result = \"\"\r\n//\r\n//         // Print out the payload for each record\r\n//         message.forEach(function(record) {\r\n//             result += stringifier.printRecord(record, separator)\r\n//             result += separator\r\n//         })\r\n//\r\n//         return result.slice(0, (-1 * separator.length))\r\n//     },\r\n//\r\n//     // @record - NDEF Record\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Record\r\n//     printRecord: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//\r\n//         switch(record.tnf) {\r\n//             case ndef.constants.TNF_EMPTY:\r\n//                 result += \"Empty Record\"\r\n//                 result += separator\r\n//                 break\r\n//             case ndef.constants.TNF_WELL_KNOWN:\r\n//                 result += stringifier.printWellKnown(record, separator)\r\n//                 break\r\n//             case ndef.constants.TNF_MIME_MEDIA:\r\n//                 result += \"MIME Media\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_ABSOLUTE_URI:\r\n//                 result += \"Absolute URI\"\r\n//                 result += separator\r\n//                 result += s(record.type)    // the URI is the type\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_EXTERNAL_TYPE:\r\n//                 // AAR contains strings, other types could\r\n//                 // contain binary data\r\n//                 result += \"External\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//                 break\r\n//             default:\r\n//                 result += s(\"Can't process TNF \" + record.tnf)\r\n//         }\r\n//\r\n//         result += separator\r\n//         return result\r\n//     },\r\n//\r\n//     printWellKnown: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if (record.tnf !== ndef.constants.TNF_WELL_KNOWN) {\r\n//             return \"ERROR expecting TNF Well Known\"\r\n//         }\r\n//\r\n//         switch(record.type) {\r\n//             case ndef.constants.RTD_TEXT:\r\n//                 result += \"Text Record\"\r\n//                 result += separator\r\n//                 result += (ndef.text.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_URI:\r\n//                 result += \"URI Record\"\r\n//                 result += separator\r\n//                 result += (ndef.uri.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_SMART_POSTER:\r\n//                 result += \"Smart Poster\"\r\n//                 result += separator\r\n//                 // the payload of a smartposter is a NDEF message\r\n//                 result += stringifier.printRecords(ndef.decodeMessage(record.payload))\r\n//                 break\r\n//             default:\r\n//                 // attempt to display other types\r\n//                 result += record.type + \" Record\"\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//         }\r\n//\r\n//         return result\r\n//     }\r\n// }\r\n//\r\n// export const stringify = { stringifier }\r\n"],"names":["decode","languageCodeLength","data","slice","Buffer","from","toString","encode","text","lang","encoding","length","Array","prototype","call","protocols","prefix","protocolCode","forEach","uri","indexOf","protocol","s","bytes","record","tnf","type","id","payload","value","constants","TNF_EMPTY","TNF_WELL_KNOWN","RTD_TEXT","decodeTextPayload","RTD_URI","decodeUriPayload","encodeMessage","encoded","tnf_byte","record_type","payload_length","id_length","i","mb","me","ndefRecords","encodeTnf","sr","il","push","concat","decodeTnf","cf","languageCode","encodeTextPayload","encodeUriPayload","TNF_ABSOLUTE_URI","mimeType","TNF_MIME_MEDIA","Error","Object","hasOwnProperty","RTD_SMART_POSTER","TNF_EXTERNAL_TYPE","packageName","_bytes","header","type_length","shift","splice","ndef_message"],"mappings":"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"}